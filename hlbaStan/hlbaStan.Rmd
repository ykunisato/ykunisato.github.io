---
title: "RStanによる反応時間の階層ベイズ解析：Linear Ballistic Accumulator modelを用いて"
author: "専修大学人間科学部心理学科　国里愛彦"
date: "2016年12月22日"
output:
  html_document:
    md_extensions: -ascii_identifiers
    theme: readable
    toc: yes
    toc_float: yes
---


# はじめに

[Linear Ballistic Accumulator modelを用いた反応時間分析](https://ykunisato.github.io/lbaStan/lbaStan.html)では，１名の参加者の反応時間データをRstanのユーザー定義関数を活用しながら解析する方法について解説を行いました。その際に，試行数は500施行という現実的ではない値を用いていました。今回は，10名が100試行反応するというありえそうな状況を想定してみます。

# 使用パッケージ

今回は，以下のパッケージを用います。

```{r, message=FALSE, warning=FALSE}
# グラフィカルモデル用
library(DiagrammeR)
# グラフ作成用
library(ggplot2)
library(plotly)
library(bayesplot)
# Stan用
library(rstan)
library(loo)
# Linear Ballistic Accumulator model用データの生成
library(rtdists)
```

# 10名分のデータの作成

rtdistsのrLBA関数を用いて，


A=0.5, b=1, tau(ここではt0) = 0.5, v[1]=2, v[2]=1.5, s=1のときの反応時間と反応を500個生成しました。


作ったデータは，dataに格納し，さらにstanDataにStanで使えるようにリスト形式で保存しています。

```{r, message=FALSE, warning=FALSE}
#データセットの作成
set.seed(1234)
data <- rLBA(500, A=0.5, b=1, t0 = 0.5, mean_v=c(2, 1.5), sd_v=c(1,1))
trialLength = length(data$rt)
stanData <- list(rt=data$rt,res=data$response,LENGTH=trialLength,NUM_CHOICES=2)
```




```{r}
#simulation parameters
TEST_LENGTH = 100
NUM_SUBJ = 2
NUM_COND = 3
NUM_CHOICES = 2

#mcmc parameters
model = 'lba_hier.stan'
warmup = 500
iter = 1000
chains = 3

#group-level parameters
A_mu = .5
k_mu = .5
t0_mu = .5
v1_mu_c1 = 2
v2_mu_c1 = 2
v3_mu_c1 = 2
v1_mu_c2 = 3
v2_mu_c2 = 2
v3_mu_c2 = 1
v1_mu_c3 = 4
v2_mu_c3 = 2
v3_mu_c3 = 3
s = 1

#individual-level parameters
A = rtnorm(NUM_SUBJ,A_mu,.5,0,Inf)
k = rtnorm(NUM_SUBJ,k_mu,.5,0,Inf)
t0 = rtnorm(NUM_SUBJ,t0_mu,.5,0,1)
v1_c1 = rtnorm(NUM_SUBJ,v1_mu_c1,1,0,Inf)
v2_c1 = rtnorm(NUM_SUBJ,v2_mu_c1,1,0,Inf)
v3_c1 = rtnorm(NUM_SUBJ,v3_mu_c1,1,0,Inf)
v1_c2 = rtnorm(NUM_SUBJ,v1_mu_c2,1,0,Inf)
v2_c2 = rtnorm(NUM_SUBJ,v2_mu_c2,1,0,Inf)
v3_c2 = rtnorm(NUM_SUBJ,v3_mu_c2,1,0,Inf)
v1_c3 = rtnorm(NUM_SUBJ,v1_mu_c3,1,0,Inf)
v2_c3 = rtnorm(NUM_SUBJ,v2_mu_c3,1,0,Inf)
v3_c3 = rtnorm(NUM_SUBJ,v3_mu_c3,1,0,Inf)

#make simulated data 
RT = array(NA,dim = c(NUM_SUBJ,NUM_COND,2,TEST_LENGTH))
for(i in 1:NUM_SUBJ){
     out1 = rlba(TEST_LENGTH,k[i]+A[i],A[i],c(v1_c1[i],v2_c1[i]),1,t0[i])
     out2 = rlba(TEST_LENGTH,k[i]+A[i],A[i],c(v1_c2[i],v2_c2[i]),1,t0[i])
     out3 = rlba(TEST_LENGTH,k[i]+A[i],A[i],c(v1_c3[i],v2_c3[i]),1,t0[i])
     RT[i,1,1,] = out1$rt
     RT[i,2,1,] = out2$rt
     RT[i,3,1,] = out3$rt
     RT[i,1,2,] = out1$resp
     RT[i,2,2,] = out2$resp
     RT[i,3,2,] = out3$resp
}

#make data list to give to Stan
data = list(RT=RT, TEST_LENGTH=TEST_LENGTH, NUM_SUBJ=NUM_SUBJ, NUM_COND=NUM_COND, NUM_CHOICES=NUM_CHOICES)
```


```{r}
#run stan model
fit <- stan(file=model, data = data,iter = iter, chains = chains,warmup=warmup)

#plot chains
traceplot(fit)

#model summary
print(fit)
```




## データの確認

選択肢ごとの反応数です。

```{r, message=FALSE, warning=FALSE}
table(data$response)
```

選択肢ごとの反応時間のヒストグラムです。

```{r, message=FALSE, warning=FALSE}
# 選択肢1の反応時間
data1 <- subset(data,data$response==1)
p1 <- ggplot(data1,aes(x = rt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))

# 選択肢2の反応時間
data2 <- subset(data,data$response==2)
p2 <- ggplot(data2,aes(x = rt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))
subplot(p1, p2)
```




## グラフィカルモデル

DiagrammeRのgrVizを使って，グラフィカルモデルを描いてみました。むしろ面倒ではないかという気もしますが(例えば，sとLBAの間のエッジはそのままだと隣のノードと重なるので，tailportとかheadportとのか設定を追加しています)，慣れれば多分便利です。多分。

```{r}
grViz("
  digraph dot {
    graph [splines = line,compound = true, nodesep = .5, ranksep = .25,
           color = black, label='Linear Ballistic Accumulator Model for single participant']
      node [shape = circle,style = filled,fillcolor = white,color = black,label = 'k'] k
      node [label = 'A'] A
      node [label = '&tau;'] t
      node [label = 'v[1]'] v1
      node [label = 'v[2]'] v2
      node [label = 'S'] s
      node [label = 'LBA@_{t}'] lba
      node [fillcolor = grey,label = 'RT@_{t}'] rt
        subgraph cluster3 {
          labelloc=b
          label = 'Trials t = 1...T'
            edge [color = black]
              lba -> rt
        }
      edge [color = black]
        A -> lba
        v1 -> lba
        v2 -> lba
        k -> lba
        t -> lba
        s -> lba [taolport=s,headport=e]
  }",engine = "dot")
```

事前分布はAnnisらを参考に以下にしました。
$$ 
k \sim Normal(.5,1)T[0,]\\
A \sim Normal(.5,1)T[0,]\\
\tau \sim Normal(.5,.5)T[0,]\\
v[1],v[2] \sim Normal(2,1)T[0,]\\
S = 1 \hspace{30pt}※Sは定数
$$




## Stanコード

上記で設定したfunctionブロックだけでなく，dataブロック以降も書きました。

※なお，以降は，@kazutan氏の[Stan Advent 2016の記事](http://qiita.com/kazutan/items/6cc162bc3c4b1b9062f2)を参考に，R MarkdownにStanコード直書きしてコンパイルする方法をとっています。つまり，チャンクで，{stan output.var="lbaModel"}と指定しています。私のRの利用の仕方からすると，これ便利です。

```{stan output.var="lbaModel"}
functions{
     
     real lba_pdf(real t, real b, real A, real v, real s){
          //PDF of the LBA model
          
          real b_A_tv_ts;
          real b_tv_ts;
          real term_1;
          real term_2;
          real term_3;
          real term_4;
          real pdf;
          
          b_A_tv_ts = (b - A - t*v)/(t*s);
          b_tv_ts = (b - t*v)/(t*s);
          term_1 = v*Phi(b_A_tv_ts);
          term_2 = s*exp(normal_lpdf(b_A_tv_ts|0,1)); 
          term_3 = v*Phi(b_tv_ts);
          term_4 = s*exp(normal_lpdf(b_tv_ts|0,1)); 
          pdf = (1/A)*(-term_1 + term_2 + term_3 - term_4);
          
          return pdf;
     }
     
     real lba_cdf(real t, real b, real A, real v, real s){
          //CDF of the LBA model
          
          real b_A_tv;
          real b_tv;
          real ts;
          real term_1;
          real term_2;
          real term_3;
          real term_4;
          real cdf;	
          
          b_A_tv = b - A - t*v;
          b_tv = b - t*v;
          ts = t*s;
          term_1 = b_A_tv/A * Phi(b_A_tv/ts);	
          term_2 = b_tv/A   * Phi(b_tv/ts);
          term_3 = ts/A     * exp(normal_lpdf(b_A_tv/ts|0,1)); 
          term_4 = ts/A     * exp(normal_lpdf(b_tv/ts|0,1)); 
          cdf = 1 + term_1 - term_2 + term_3 - term_4;
          
          return cdf;
          
     }
     
    real lba_lpdf(real rt, real res, real k, real A, vector v, real s, real tau){
        
        real t;
        real b;
        real cdf;
        real pdf;		
        real prob;
        real out;
        real prob_neg;
    
        b = A + k;
        t = rt - tau;
        
        if(t > 0){			
              cdf = 1;
              for(j in 1 : num_elements(v)){
                    if(res == j){
                          pdf = lba_pdf(t, b, A, v[j], s);
                    }else{	
                          cdf = (1 - lba_cdf(t, b, A, v[j], s)) * cdf;
                    }
              }
              
              prob_neg = 1;
              for(j in 1:num_elements(v)){
                    prob_neg = Phi(-v[j] / s) * prob_neg;    
              }
              prob = pdf * cdf;		
              prob = prob / (1 - prob_neg);	
              if(prob < 1e-10){
                    prob = 1e-10;				
              }
        }else{
            prob = 1e-10;			
        }
        out = log(prob);
        return out;		
    }
     
    vector lba_rng(real k, real A, vector v, real s, real tau){
          
          int get_pos_drift;	
          int no_pos_drift;
          int get_first_pos;
          vector[num_elements(v)] drift;
          int max_iter;
          int iter;
          real start[num_elements(v)];
          real ttf[num_elements(v)];
          int resp[num_elements(v)];
          real rt;
          vector[2] pred;
          real b;
          
          //try to get a positive drift rate
          get_pos_drift = 1;
          no_pos_drift = 0;
          max_iter = 1000;
          iter = 0;
          while(get_pos_drift){
               for(j in 1:num_elements(v)){
                    drift[j] = normal_rng(v[j],s);
                    if(drift[j] > 0){
                         get_pos_drift = 0;
                    }
               }
               iter = iter + 1;
               if(iter > max_iter){
                    get_pos_drift = 0;
                    no_pos_drift = 1;
               }	
          }
          //if both drift rates are <= 0
          //return an infinite response time
          if(no_pos_drift){
               pred[1] = -1;
               pred[2] = -1;
          }else{
               b = A + k;
               for(i in 1:num_elements(v)){
                    //start time of each accumulator	
                    start[i] = uniform_rng(0,A);
                    //finish times
                    ttf[i] = (b-start[i])/drift[i];
               }
               //rt is the fastest accumulator finish time	
               //if one is negative get the positive drift
               resp = sort_indices_asc(ttf);
               ttf = sort_asc(ttf);
               get_first_pos = 1;
               iter = 1;
               while(get_first_pos){
                    if(ttf[iter] > 0){
                         pred[1] = ttf[iter] + tau;
                         pred[2] = resp[iter]; 
                         get_first_pos = 0;
                    }
                    iter = iter + 1;
               }
          }
          return pred;	
     }
}

data{
     int LENGTH;
     int NUM_CHOICES;
     vector[LENGTH] rt;
     vector[LENGTH] res;
}

parameters {
     real<lower=0> k;
     real<lower=0> A;
     real<lower=0> tau;
     vector<lower=0>[NUM_CHOICES] v;
}

transformed parameters {
     real s;
     s = 1;
}

model {
     k ~ normal(.5,1)T[0,];
     A ~ normal(.5,1)T[0,];
     tau ~ normal(.5,.5)T[0,];
     for(n in 1:NUM_CHOICES){
          v[n] ~ normal(2,1)T[0,];
     }
     
     for(m in 1:LENGTH){
          rt[m] ~ lba(res[m],k,A,v,s,tau);
     }
}

generated quantities {
     vector[2] pred;
     vector[LENGTH] log_lik;
     
     pred = lba_rng(k,A,v,s,tau);
    
     for(i in 1 : LENGTH){
          log_lik[i] = lba_lpdf(rt[i] | res[i], k, A, v, s, tau);
     }
}
```


モデル1（HLBA1.stan)：vもAもtimeに対し一定（階層パラメータは、２群で一定）

### モデル１のStanコード

```{r}
model1<-"
functions{
     
     real lba_pdf(real t, real b, real A, real v, real s){
          //PDF of the LBA model
          
          real b_A_tv_ts;
          real b_tv_ts;
          real term_1;
          real term_2;
          real term_3;
          real term_4;
          real pdf;
          
          b_A_tv_ts = (b - A - t*v)/(t*s);
          b_tv_ts = (b - t*v)/(t*s);
          term_1 = v*Phi(b_A_tv_ts);
          term_2 = s*exp(normal_lpdf(b_A_tv_ts|0,1));
          term_3 = v*Phi(b_tv_ts);
          term_4 = s*exp(normal_lpdf(b_tv_ts|0,1)); 
          pdf = (1 / A)*(-term_1 + term_2 + term_3 - term_4);
          
          return pdf;
     }
     
     real lba_cdf(real t, real b, real A, real v, real s){
          //CDF of the LBA model
          
          real b_A_tv;
          real b_tv;
          real ts;
          real term_1;
          real term_2;
          real term_3;
          real term_4;
          real cdf;	
          
          b_A_tv = b - A - t*v;
          b_tv = b - t*v;
          ts = t*s;
          term_1 = b_A_tv/A * Phi(b_A_tv/ts);	
          term_2 = b_tv/A   * Phi(b_tv/ts);
          term_3 = ts/A     * exp(normal_lpdf(b_A_tv/ts|0,1)); 
          term_4 = ts/A     * exp(normal_lpdf(b_tv/ts|0,1)); 
          cdf = 1 + term_1 - term_2 + term_3 - term_4;
          
          return cdf;
          
     }
     
     real lba_lpdf(real rt, real res, real k, real A, vector v, real s, real tau){
          
          real t;
          real b;
          real cdf;
          real pdf;		
          real prob;
          real out;
          real prob_neg;

          b = A + k;
          t = rt - tau;
          
          if(t > 0){			
                cdf = 1;
                for(j in 1 : num_elements(v)){
                      if(res == j){
                            pdf = lba_pdf(t, b, A, v[j], s);
                      }else{	
                            cdf = (1 - lba_cdf(t, b, A, v[j], s)) * cdf;
                      }
                }
                
                prob_neg = 1;
                for(j in 1 : num_elements(v)){
                      prob_neg = Phi(-v[j]/s) * prob_neg;    
                }
                prob = pdf*cdf;		
                prob = prob/(1 - prob_neg);	
                if(prob < 1e-10){
                      prob = 1e-10;				
                }
          }else{
              prob = 1e-10;			
          }
          out = log(prob);
          return out;		
     }
     
    vector lba_rng(real k, real A, vector v, real s, real tau){
          
          int get_pos_drift;	
          int no_pos_drift;
          int get_first_pos;
          vector[num_elements(v)] drift;
          int max_iter;
          int iter;
          real start[num_elements(v)];
          real ttf[num_elements(v)];
          int resp[num_elements(v)];
          real rt;
          vector[2] pred;
          real b;
          
          //try to get a positive drift rate
          get_pos_drift = 1;
          no_pos_drift = 0;
          max_iter = 1000;
          iter = 0;
          while(get_pos_drift){
               for(j in 1 : num_elements(v)){
                    drift[j] = normal_rng(v[j],s);
                    if(drift[j] > 0){
                         get_pos_drift = 0;
                    }
               }
               iter = iter + 1;
               if(iter > max_iter){
                    get_pos_drift = 0;
                    no_pos_drift = 1;
               }	
          }
          //if both drift rates are <= 0
          //return an infinite response time
          if(no_pos_drift){
               pred[1] = -1;
               pred[2] = -1;
          }else{
               b = A + k;
               for(i in 1 : num_elements(v)){
                    //start time of each accumulator	
                    start[i] = uniform_rng(0, A);
                    //finish times
                    ttf[i] = (b-start[i])/drift[i];
               }
               //rt is the fastest accumulator finish time	
               //if one is negative get the positive drift
               resp = sort_indices_asc(ttf);
               ttf = sort_asc(ttf);
               get_first_pos = 1;
               iter = 1;
               while(get_first_pos){
                    if(ttf[iter] > 0){
                         pred[1] = ttf[iter] + tau;
                         pred[2] = resp[iter]; 
                         get_first_pos = 0;
                    }
                    iter = iter + 1;
               }
          }
          return pred;	
     }
}

data{
     int TRIAL_LENGTH;
     int NUM_COND;
     int NUM_SUBJ;
     int NUM_CHOICES;
     int allTrial;
     vector[allTrial] rt;
     vector[allTrial] res;
     int group[NUM_SUBJ];
     int time[allTrial];
     int id[allTrial];
}

parameters {
     real<lower=0> k[NUM_SUBJ];
     real<lower=0> A[NUM_SUBJ];
     real<lower=0> psi[NUM_SUBJ];
     vector<lower=0> [NUM_CHOICES] v [NUM_SUBJ];
     real<lower=0> k_sigma;
     real<lower=0> A_sigma;
     real<lower=0> psi_sigma;
     vector<lower=0> [NUM_CHOICES] v_sigma;
     real<lower=0> k_mu;
     real<lower=0> A_mu;
     real<lower=0> psi_mu;
     vector<lower=0> [NUM_CHOICES] v_mu;
}

transformed parameters {
     real s;
     s = 1;
}

model {
     int subIndex;
     int condIndex;
     k_mu ~ normal(.5, 1)T[0, ];
     A_mu ~ normal(.5, 1)T[0, ];
     psi_mu ~ normal(.5, .5)T[0, ];
     k_sigma ~ student_t(4, 0, 1)T[0, ];
     A_sigma ~ student_t(4, 0, 1)T[0, ];
     psi_sigma ~ student_t(4, 0, 1)T[0, ];
     
     for(n in 1 : NUM_CHOICES){
        v_mu[n] ~ normal(2, 1)T[0, ];
        v_sigma[n] ~ student_t(4, 0, 1)T[0, ];
      }
     
     for(i in 1:NUM_SUBJ){		
          k[i] ~ normal(k_mu, k_sigma)T[0, ];
          A[i] ~ normal(A_mu, A_sigma)T[0, ];
          psi[i] ~ normal(psi_mu, psi_sigma)T[0, ];

          for(n in 1 : NUM_CHOICES){
              v[i,n] ~ normal(v_mu[n],v_sigma[n])T[0, ];
          }
     }
    
    for(m in 1 : allTrial){
           subIndex = id[m];
          rt[m] ~ lba(res[m], k[subIndex], A[subIndex], v[subIndex], s, psi[subIndex]);
    }
}

generated quantities {
     vector[2] pred[NUM_SUBJ,NUM_COND];
     vector[allTrial] log_lik;
     int subIndex;
     int condIndex;
     
     for(i in 1 : NUM_SUBJ){
          for(j in 1 : NUM_COND){
               pred[i, j] = lba_rng(A[i], k[i], v[i], s, psi[i]);
          }
     }

    for(m in 1 : allTrial){
          subIndex = id[m];
          log_lik[m] = lba_lpdf(rt[m] | res[m], k[subIndex], A[subIndex], v[subIndex], s, psi[subIndex]);
    }
     
}
"
```

## Rstanによるサンプリング

さてさて，サンプリングしてみます。

```{r, message=FALSE, warning=FALSE}
rstan_options(auto_write=TRUE)
options(mc.cores = parallel::detectCores())
hmcIter = 1000
hmcChains = 4
hmcWarmup = 300
hmcThin = 2

fit <- sampling(lbaModel, 
            seed = 1234, 
            data = stanData,
            warmup = hmcWarmup, 
            iter = hmcIter,
            chains = hmcChains,
            thin =hmcThin)
```

## 収束判定{.tabset}
まあ，収束してそうですね。収束判定には，bayesplotを活用しています。[このページ](https://cran.rstudio.com/web/packages/bayesplot/vignettes/MCMC-diagnostics.html)が参考になりました。なお，定数のSは除外しています。

### トレースプロット
```{r, message=FALSE, warning=FALSE}
posterior1 <- extract(fit, inc_warmup = TRUE, permuted = FALSE)
color_scheme_set("mix-blue-pink")
p <- mcmc_trace(posterior1,  pars = c("k", "A", "tau", "v[1]", "v[2]"), n_warmup = 125,
                facet_args = list(nrow = 2, labeller = label_parsed))
p <- p+ facet_text(size = 15)
plot(p)
```

### $\hat{R}$の確認

```{r, message=FALSE, warning=FALSE}
color_scheme_set("brightblue")
rhats <- rhat(fit,par = c("k", "A", "tau", "v[1]", "v[2]"))
print(rhats)
mcmc_rhat(rhats) + yaxis_text()
```

### 有効サンプルサイズ
```{r, message=FALSE, warning=FALSE}
neffRatios <- neff_ratio(fit,par = c("k", "A", "tau", "v[1]", "v[2]"))
print(neffRatios)
mcmc_neff(neffRatios) + yaxis_text()
```

### 自己相関
```{r, message=FALSE, warning=FALSE}
posterior2 <- as.matrix(fit)
mcmc_acf(posterior2, pars = c("k","A","tau","v[1]","v[2]"), lags = 10)
```

## No-U-Turn Samplerの診断{.tabset}
bayesplotで簡単に描けたので，載っけてみました。

### Divergent transitions

```{r, message=FALSE, warning=FALSE}
mcmc_nuts_divergence(nuts_params(fit), log_posterior(fit))
```

### Energy and Bayesian fraction of missing information

```{r, message=FALSE, warning=FALSE}
mcmc_nuts_energy(nuts_params(fit),merge_chains = FALSE)
```

## 推定結果

MAP推定値も計算してみました。
```{r, message=FALSE, warning=FALSE}
extractFit <- rstan::extract(fit)
# MAP推定値計算関数
mapEstimate <- function(z){
  density(z)$x[which.max(density(z)$y)]
}

kMap <- mapEstimate(extractFit$k)
AMap <- mapEstimate(extractFit$A)
tauMap <- mapEstimate(extractFit$tau)
v1Map <- mapEstimate(extractFit$v[,1])
v2Map <- mapEstimate(extractFit$v[,2])
```

A=0.5, b=1, tau(ここではt0) = 0.5, v[1]=2, v[2]=1.5, s=1で，データを作っていました。データの生成の段階でもノイズが入るので，まあまあパラメータリカバリできているかなとは思いますが，データ生成などのシードを変えるだけでも結構結果は変わってきます。

```{r, message=FALSE, warning=FALSE}
print(fit,par = c("k", "A", "tau", "v[1]", "v[2]","s"))
# MAP推定値
print(paste("k=",kMap,",A=",AMap,",tau=",tauMap,",v1=",v1Map,",v2=",v2Map))
```

bayesplotのmcmc_areasって便利ですね。

```{r, message=FALSE, warning=FALSE}
mcmc_areas(posterior2, pars = c("k", "A", "tau", "v[1]", "v[2]"), prob = 0.95)
```

## 事後予測チェック{.tabset}

収束もしていたので，事後予測チェックをしてみます。Stanが吐き出したpredからそれぞれ500サンプルランダムに抽出したデータセットを２つ作ってみました。

```{r, message=FALSE, warning=FALSE}
predRt = posterior2[,'pred[1]']
predRes = posterior2[,'pred[2]']
postPredData <- data.frame(predRt,predRes)

# 事後予測サンプルから500個抽出その１
set.seed(321)
sampleId<-sample(nrow(postPredData),500)
postPredData1<-postPredData[sampleId,]

# 事後予測サンプルから500個抽出その２
set.seed(123)
sampleId<-sample(nrow(postPredData),500)
postPredData2<-postPredData[sampleId,]
```

クロス集計で確認をします。まあまあ，良い感じかな。

```{r, message=FALSE, warning=FALSE}
table(data$response)
table(postPredData1$predRes)
table(postPredData2$predRes)
```

反応時間のヒストグラムも良い感じかな。

### 反応時間の分布（データ）

```{r, message=FALSE, warning=FALSE}
data1 <- subset(data,data$response==1)
p1 <- ggplot(data1,aes(x = rt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70)) 
data2 <- subset(data,data$response==2)
p2 <- ggplot(data2,aes(x = rt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))+ ggtitle("データの反応時間のヒストグラム（左が選択肢１，右が選択肢２）")
subplot(p1,p2)
```

### 反応時間の分布（事後予測１）

```{r, message=FALSE, warning=FALSE}
postPredData11 <- subset(postPredData1,postPredData$predRes==1)
p3 <- ggplot(postPredData11,aes(x = predRt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))
postPredData12 <- subset(postPredData1,postPredData$predRes==2)
p4 <- ggplot(postPredData12,aes(x = predRt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))+ ggtitle("事後予測の反応時間のヒストグラム　その１（左が選択肢１，右が選択肢２）")
subplot(p3,p4)
```

### 反応時間の分布（事後予測２）

```{r, message=FALSE, warning=FALSE}
postPredData21 <- subset(postPredData2,postPredData$predRes==1)
p5 <- ggplot(postPredData21,aes(x = predRt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))
postPredData22 <- subset(postPredData2,postPredData$predRes==2)
p6 <- ggplot(postPredData22,aes(x = predRt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))+ ggtitle("事後予測の反応時間のヒストグラム　その２（左が選択肢１，右が選択肢２）")
subplot(p5,p6)
```

## 情報量基準(WAICとLOOCV)の算出
@berobero11氏の[Stan Advent 2016](http://statmodeling.hatenablog.com/entry/comparison-of-LOOCV-and-WAIC)を参考にしつつWAICとLOOCVの算出をしてみた。今回は，あまり意味ないけど，今後モデル比較する場合には，活用できるかなと思います。

```{r}
loo::loo(extractFit$log_lik)$looic/(2*trialLength)
loo::waic(extractFit$log_lik)$waic/(2*trialLength)
```

ここまで出来たら，複数の参加者のデータに対して階層ベイズにもっていきたいところですが，ちょっと分量が長くなりすぎてしまったので，またの機会に！  


**Enjoy Stan!**
