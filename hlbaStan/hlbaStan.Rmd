---
title: "RStanによる反応時間の階層ベイズ解析：Linear Ballistic Accumulator modelを用いて"
author: "専修大学人間科学部心理学科　国里愛彦"
date: "2016年12月22日"
output:
  html_document:
    md_extensions: -ascii_identifiers
    theme: readable
    toc: yes
    toc_float: yes
---


# はじめに

[Linear Ballistic Accumulator modelを用いた反応時間分析](https://ykunisato.github.io/lbaStan/lbaStan.html)では，１名の参加者の反応時間データをRstanのユーザー定義関数を活用しながら解析する方法について解説を行いました。その際に，試行数は500施行という現実的ではない値を用いていました。今回は，10名が100試行反応するというありえそうな状況を想定してみます。

# 使用パッケージ

今回は，以下のパッケージを用います。

```{r, message=FALSE, warning=FALSE}
rm(list=ls())
library(DiagrammeR)
library(ggplot2)
library(plotly)
library(bayesplot)
library(rstan)
library(loo)
library(rtdists)
library(msm)
```

# 10名分のデータの作成

Annis et al. (2016)による [Bayesian inference with Stan: A tutorial on adding custom distributions](http://www.ncbi.nlm.nih.gov/pubmed/27287444)のコードを参考にしつつ，10名の参加者が３条件の２選択肢の課題をそれぞれ100試行行ったというデータを作ってみる。まずは，人数分のパラメータを準備します。

```{r, message=FALSE, warning=FALSE}
# 参加者数，試行数，条件数
numberSubject <- 10
numberTrials <- 100
numberConditions <- 3

#　ハイパーパラメータの設定
A_mu = .5
b_mu = 1
t0_mu = .5
v1_mu_c1 = 2
v2_mu_c1 = 2.5
v1_mu_c2 = 3
v2_mu_c2 = 3
v1_mu_c3 = 3.5
v2_mu_c3 = 2.5
s = 1

#　ハイパーパラメータをもとにした個人のパラメータ（切断正規分布を利用）
A = rtnorm(numberSubject,A_mu,.5,0,Inf)
b = rtnorm(numberSubject,b_mu,.5,A,Inf)
t0 = rtnorm(numberSubject,t0_mu,.5,0,1)
v1_c1 = rtnorm(numberSubject,v1_mu_c1,1,0,Inf)
v2_c1 = rtnorm(numberSubject,v2_mu_c1,1,0,Inf)
v1_c2 = rtnorm(numberSubject,v1_mu_c2,1,0,Inf)
v2_c2 = rtnorm(numberSubject,v2_mu_c2,1,0,Inf)
v1_c3 = rtnorm(numberSubject,v1_mu_c3,1,0,Inf)
v2_c3 = rtnorm(numberSubject,v2_mu_c3,1,0,Inf)

# パラメータとハイパーパラメータのデータフレーム化
hyperParameters <- data.frame(A_mu,b_mu,t0_mu,v1_mu_c1,v2_mu_c1,v1_mu_c2,v2_mu_c2,v1_mu_c3,v2_mu_c3,s)
print(hyperParameters)
parameters <- data.frame(A,b,t0,v1_c1,v2_c1,v1_c2,v2_c2,v1_c3,v2_c3)
print(parameters)
```
上記で設定したパラメータをもとに，rtdistsのrLBA関数を用いて反応時間と反応のデータを作ります。作ったデータは，ロング形式にしました。そして，stanLongDataにStanで使えるようにリスト形式でデータを保存しています。

```{r, message=FALSE, warning=FALSE}
set.seed(1234)
longData <- NULL
for(i in 1:numberSubject){
    id <- rep(i,numberTrials)
    # 条件１
    tempRt <- rLBA(numberTrials, A=parameters$A[i], b=parameters$b[i], t0=parameters$t0[i], mean_v=c(parameters$v1_c1[i],parameters$v2_c1[i]), sd_v=c(s,s))
    condition <- rep(1,numberTrials)
    indDataC1 <- data.frame(id,condition,tempRt)
    
    # 条件2
    tempRt <- rLBA(numberTrials, A=parameters$A[i], b=parameters$b[i], t0=parameters$t0[i], mean_v=c(parameters$v1_c1[i],parameters$v2_c1[i]), sd_v=c(s,s))
    condition <- rep(2,numberTrials)
    indDataC2 <- data.frame(id,condition,tempRt)
    
    # 条件3
    tempRt <- rLBA(numberTrials, A=parameters$A[i], b=parameters$b[i], t0=parameters$t0[i], mean_v=c(parameters$v1_c1[i],parameters$v2_c1[i]), sd_v=c(s,s))
    condition <- rep(3,numberTrials)
    indDataC3 <- data.frame(id,condition,tempRt)
    indData <- rbind(indDataC1,indDataC2,indDataC3)
    
    # ロングデータ
    longData <- rbind(longData,indData)
}

allTrial <- length(longData)
# Stan用データの作成
stanLongData <- list(RT=longData$rt,RES=longData$response,ID=longData$id,CONDITION = longData$condition, TRIAL_LENGTH=numberTrials,NUM_COND=numberConditions,NUM_SUBJ=numberSubject,NUM_CHOICES=2,ALLTRIAL=allTrial,NUM_CHOICES=2)
```

## データの確認




```{r, message=FALSE, warning=FALSE}


table(data$response)
# 選択肢1の反応時間
data1 <- subset(data,data$response==1)
p1 <- ggplot(data1,aes(x = rt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))

# 選択肢2の反応時間
data2 <- subset(data,data$response==2)
p2 <- ggplot(data2,aes(x = rt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))
subplot(p1, p2)
```




## グラフィカルモデル

DiagrammeRのgrVizを使って，グラフィカルモデルを描いてみました。むしろ面倒ではないかという気もしますが(例えば，sとLBAの間のエッジはそのままだと隣のノードと重なるので，tailportとかheadportとのか設定を追加しています)，慣れれば多分便利です。多分。

```{r}
grViz("
  digraph dot {
    graph [splines = line,compound = true, nodesep = .5, ranksep = .25,
           color = black, label='Linear Ballistic Accumulator Model for single participant']
      node [shape = circle,style = filled,fillcolor = white,color = black,label = 'k'] k
      node [label = 'A'] A
      node [label = '&tau;'] t
      node [label = 'v[1]'] v1
      node [label = 'v[2]'] v2
      node [label = 'S'] s
      node [label = 'LBA@_{t}'] lba
      node [fillcolor = grey,label = 'RT@_{t}'] rt
        subgraph cluster3 {
          labelloc=b
          label = 'Trials t = 1...T'
            edge [color = black]
              lba -> rt
        }
      edge [color = black]
        A -> lba
        v1 -> lba
        v2 -> lba
        k -> lba
        t -> lba
        s -> lba [taolport=s,headport=e]
  }",engine = "dot")
```

事前分布はAnnisらを参考に以下にしました。
$$ 
k \sim Normal(.5,1)T[0,]\\
A \sim Normal(.5,1)T[0,]\\
\tau \sim Normal(.5,.5)T[0,]\\
v[1],v[2] \sim Normal(2,1)T[0,]\\
S = 1 \hspace{30pt}※Sは定数
$$

ハイパーパラメータも
$$ 
k_{i} \sim Normal(\mu_{k},\sigma_{k})T(0,\infty)\\
A_{i} \sim Normal(\mu_{A},\sigma_{A})T(0,\infty)\\
\tau_{i} \sim Normal(\mu_{\tau},\sigma_{\tau})T(0,\infty)\\
v1_{i} \sim Normal(\mu_{v1},\sigma_{v1})T(0,\infty)\\
v2_{i} \sim| Normal(\mu_{v2},\sigma_{v2})T(0,\infty)\\
\mu^{A},\mu^{k} \sim Normal(0.5,1)T(0,\infty)\\
\mu^{\tau} \sim Normal(0.5,0.5)T(0,\infty)\\
\mu^{v1},\mu^{v2} \sim Normal(2,1)T(0,\infty)\\
\sigma^{A},\sigma^{k}, \sigma^{v1},\sigma^{v2},\sigma^{\tau} \sim student_t(4,0,1)T(0,\infty) [Gamma(1,1)から変更]\\ 
S = 1 [Sは定数]\\
RT[t, i] \sim LBA(k_{i},A_{i},\tau_{i},v1_{i,j},s) [選択肢１の時]\\
RT[t, i] \sim LBA(k_{i},A_{i},\tau_{i},v2_{i,j},s) [選択肢2の時]
$$

### 階層ベイズモデル
vもAもConditionに対して一定

```{stan output.var="lbaModel1"}
functions{
     
     real lba_pdf(real t, real b, real A, real v, real s){
          //PDF of the LBA model
          
          real b_A_tv_ts;
          real b_tv_ts;
          real term_1;
          real term_2;
          real term_3;
          real term_4;
          real pdf;
          
          b_A_tv_ts = (b - A - t*v)/(t*s);
          b_tv_ts = (b - t*v)/(t*s);
          term_1 = v*Phi(b_A_tv_ts);
          term_2 = s*exp(normal_lpdf(b_A_tv_ts|0,1));
          term_3 = v*Phi(b_tv_ts);
          term_4 = s*exp(normal_lpdf(b_tv_ts|0,1)); 
          pdf = (1 / A)*(-term_1 + term_2 + term_3 - term_4);
          
          return pdf;
     }
     
     real lba_cdf(real t, real b, real A, real v, real s){
          //CDF of the LBA model
          
          real b_A_tv;
          real b_tv;
          real ts;
          real term_1;
          real term_2;
          real term_3;
          real term_4;
          real cdf;	
          
          b_A_tv = b - A - t*v;
          b_tv = b - t*v;
          ts = t*s;
          term_1 = b_A_tv/A * Phi(b_A_tv/ts);	
          term_2 = b_tv/A   * Phi(b_tv/ts);
          term_3 = ts/A     * exp(normal_lpdf(b_A_tv/ts|0,1)); 
          term_4 = ts/A     * exp(normal_lpdf(b_tv/ts|0,1)); 
          cdf = 1 + term_1 - term_2 + term_3 - term_4;
          
          return cdf;
          
     }
     
     real lba_lpdf(real rt, real res, real k, real A, vector v, real s, real tau){
          
          real t;
          real b;
          real cdf;
          real pdf;		
          real prob;
          real out;
          real prob_neg;

          b = A + k;
          t = rt - tau;
          
          if(t > 0){			
                cdf = 1;
                for(j in 1 : num_elements(v)){
                      if(res == j){
                            pdf = lba_pdf(t, b, A, v[j], s);
                      }else{	
                            cdf = (1 - lba_cdf(t, b, A, v[j], s)) * cdf;
                      }
                }
                
                prob_neg = 1;
                for(j in 1 : num_elements(v)){
                      prob_neg = Phi(-v[j]/s) * prob_neg;    
                }
                prob = pdf*cdf;		
                prob = prob/(1 - prob_neg);	
                if(prob < 1e-10){
                      prob = 1e-10;				
                }
          }else{
              prob = 1e-10;			
          }
          out = log(prob);
          return out;		
     }
     
    vector lba_rng(real k, real A, vector v, real s, real tau){
          
          int get_pos_drift;	
          int no_pos_drift;
          int get_first_pos;
          vector[num_elements(v)] drift;
          int max_iter;
          int iter;
          real start[num_elements(v)];
          real ttf[num_elements(v)];
          int resp[num_elements(v)];
          real rt;
          vector[2] pred;
          real b;
          
          //try to get a positive drift rate
          get_pos_drift = 1;
          no_pos_drift = 0;
          max_iter = 1000;
          iter = 0;
          while(get_pos_drift){
               for(j in 1 : num_elements(v)){
                    drift[j] = normal_rng(v[j],s);
                    if(drift[j] > 0){
                         get_pos_drift = 0;
                    }
               }
               iter = iter + 1;
               if(iter > max_iter){
                    get_pos_drift = 0;
                    no_pos_drift = 1;
               }	
          }
          //if both drift rates are <= 0
          //return an infinite response time
          if(no_pos_drift){
               pred[1] = -1;
               pred[2] = -1;
          }else{
               b = A + k;
               for(i in 1 : num_elements(v)){
                    //start time of each accumulator	
                    start[i] = uniform_rng(0, A);
                    //finish times
                    ttf[i] = (b-start[i])/drift[i];
               }
               //rt is the fastest accumulator finish time	
               //if one is negative get the positive drift
               resp = sort_indices_asc(ttf);
               ttf = sort_asc(ttf);
               get_first_pos = 1;
               iter = 1;
               while(get_first_pos){
                    if(ttf[iter] > 0){
                         pred[1] = ttf[iter] + tau;
                         pred[2] = resp[iter]; 
                         get_first_pos = 0;
                    }
                    iter = iter + 1;
               }
          }
          return pred;	
     }
}

data{
     int TRIAL_LENGTH;
     int NUM_COND;
     int NUM_SUBJ;
     int NUM_CHOICES;
     int allTrial;
     vector[allTrial] rt;
     vector[allTrial] res;
     int group[NUM_SUBJ];
     int time[allTrial];
     int id[allTrial];
}

parameters {
     real<lower=0> k[NUM_SUBJ];
     real<lower=0> A[NUM_SUBJ];
     real<lower=0> psi[NUM_SUBJ];
     vector<lower=0> [NUM_CHOICES] v [NUM_SUBJ];
     real<lower=0> k_sigma;
     real<lower=0> A_sigma;
     real<lower=0> psi_sigma;
     vector<lower=0> [NUM_CHOICES] v_sigma;
     real<lower=0> k_mu;
     real<lower=0> A_mu;
     real<lower=0> psi_mu;
     vector<lower=0> [NUM_CHOICES] v_mu;
}

transformed parameters {
     real s;
     s = 1;
}

model {
     int subIndex;
     int condIndex;
     k_mu ~ normal(.5, 1)T[0, ];
     A_mu ~ normal(.5, 1)T[0, ];
     psi_mu ~ normal(.5, .5)T[0, ];
     k_sigma ~ student_t(4, 0, 1)T[0, ];
     A_sigma ~ student_t(4, 0, 1)T[0, ];
     psi_sigma ~ student_t(4, 0, 1)T[0, ];
     
     for(n in 1 : NUM_CHOICES){
        v_mu[n] ~ normal(2, 1)T[0, ];
        v_sigma[n] ~ student_t(4, 0, 1)T[0, ];
      }
     
     for(i in 1:NUM_SUBJ){		
          k[i] ~ normal(k_mu, k_sigma)T[0, ];
          A[i] ~ normal(A_mu, A_sigma)T[0, ];
          psi[i] ~ normal(psi_mu, psi_sigma)T[0, ];

          for(n in 1 : NUM_CHOICES){
              v[i,n] ~ normal(v_mu[n],v_sigma[n])T[0, ];
          }
     }
    
    for(m in 1 : allTrial){
           subIndex = id[m];
          rt[m] ~ lba(res[m], k[subIndex], A[subIndex], v[subIndex], s, psi[subIndex]);
    }
}

generated quantities {
     vector[2] pred[NUM_SUBJ,NUM_COND];
     vector[allTrial] log_lik;
     int subIndex;
     int condIndex;
     
     for(i in 1 : NUM_SUBJ){
          for(j in 1 : NUM_COND){
               pred[i, j] = lba_rng(A[i], k[i], v[i], s, psi[i]);
          }
     }

    for(m in 1 : allTrial){
          subIndex = id[m];
          log_lik[m] = lba_lpdf(rt[m] | res[m], k[subIndex], A[subIndex], v[subIndex], s, psi[subIndex]);
    }
     
}
```

## Rstanによるサンプリング

さてさて，サンプリングしてみます。

```{r, message=FALSE, warning=FALSE}
rstan_options(auto_write=TRUE)
options(mc.cores = parallel::detectCores())
hmcIter = 1000
hmcChains = 4
hmcWarmup = 300
hmcThin = 2

fit <- sampling(lbaModel, 
            seed = 1234, 
            data = stanData,
            warmup = hmcWarmup, 
            iter = hmcIter,
            chains = hmcChains,
            thin =hmcThin)
```

## 収束判定{.tabset}
まあ，収束してそうですね。収束判定には，bayesplotを活用しています。[このページ](https://cran.rstudio.com/web/packages/bayesplot/vignettes/MCMC-diagnostics.html)が参考になりました。なお，定数のSは除外しています。

### トレースプロット
```{r, message=FALSE, warning=FALSE}
posterior1 <- extract(fit, inc_warmup = TRUE, permuted = FALSE)
color_scheme_set("mix-blue-pink")
p <- mcmc_trace(posterior1,  pars = c("k", "A", "tau", "v[1]", "v[2]"), n_warmup = 125,
                facet_args = list(nrow = 2, labeller = label_parsed))
p <- p+ facet_text(size = 15)
plot(p)
```

### $\hat{R}$の確認

```{r, message=FALSE, warning=FALSE}
color_scheme_set("brightblue")
rhats <- rhat(fit,par = c("k", "A", "tau", "v[1]", "v[2]"))
print(rhats)
mcmc_rhat(rhats) + yaxis_text()
```

### 有効サンプルサイズ
```{r, message=FALSE, warning=FALSE}
neffRatios <- neff_ratio(fit,par = c("k", "A", "tau", "v[1]", "v[2]"))
print(neffRatios)
mcmc_neff(neffRatios) + yaxis_text()
```

### 自己相関
```{r, message=FALSE, warning=FALSE}
posterior2 <- as.matrix(fit)
mcmc_acf(posterior2, pars = c("k","A","tau","v[1]","v[2]"), lags = 10)
```

## No-U-Turn Samplerの診断{.tabset}
bayesplotで簡単に描けたので，載っけてみました。

### Divergent transitions

```{r, message=FALSE, warning=FALSE}
mcmc_nuts_divergence(nuts_params(fit), log_posterior(fit))
```

### Energy and Bayesian fraction of missing information

```{r, message=FALSE, warning=FALSE}
mcmc_nuts_energy(nuts_params(fit),merge_chains = FALSE)
```

## 推定結果

MAP推定値も計算してみました。
```{r, message=FALSE, warning=FALSE}
extractFit <- rstan::extract(fit)
# MAP推定値計算関数
mapEstimate <- function(z){
  density(z)$x[which.max(density(z)$y)]
}

kMap <- mapEstimate(extractFit$k)
AMap <- mapEstimate(extractFit$A)
tauMap <- mapEstimate(extractFit$tau)
v1Map <- mapEstimate(extractFit$v[,1])
v2Map <- mapEstimate(extractFit$v[,2])
```

A=0.5, b=1, tau(ここではt0) = 0.5, v[1]=2, v[2]=1.5, s=1で，データを作っていました。データの生成の段階でもノイズが入るので，まあまあパラメータリカバリできているかなとは思いますが，データ生成などのシードを変えるだけでも結構結果は変わってきます。

```{r, message=FALSE, warning=FALSE}
print(fit,par = c("k", "A", "tau", "v[1]", "v[2]","s"))
# MAP推定値
print(paste("k=",kMap,",A=",AMap,",tau=",tauMap,",v1=",v1Map,",v2=",v2Map))
```

bayesplotのmcmc_areasって便利ですね。

```{r, message=FALSE, warning=FALSE}
mcmc_areas(posterior2, pars = c("k", "A", "tau", "v[1]", "v[2]"), prob = 0.95)
```

## 事後予測チェック{.tabset}

収束もしていたので，事後予測チェックをしてみます。Stanが吐き出したpredからそれぞれ500サンプルランダムに抽出したデータセットを２つ作ってみました。

```{r, message=FALSE, warning=FALSE}
predRt = posterior2[,'pred[1]']
predRes = posterior2[,'pred[2]']
postPredData <- data.frame(predRt,predRes)

# 事後予測サンプルから500個抽出その１
set.seed(321)
sampleId<-sample(nrow(postPredData),500)
postPredData1<-postPredData[sampleId,]

# 事後予測サンプルから500個抽出その２
set.seed(123)
sampleId<-sample(nrow(postPredData),500)
postPredData2<-postPredData[sampleId,]
```

クロス集計で確認をします。まあまあ，良い感じかな。

```{r, message=FALSE, warning=FALSE}
table(data$response)
table(postPredData1$predRes)
table(postPredData2$predRes)
```

反応時間のヒストグラムも良い感じかな。

### 反応時間の分布（データ）

```{r, message=FALSE, warning=FALSE}
data1 <- subset(data,data$response==1)
p1 <- ggplot(data1,aes(x = rt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70)) 
data2 <- subset(data,data$response==2)
p2 <- ggplot(data2,aes(x = rt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))+ ggtitle("データの反応時間のヒストグラム（左が選択肢１，右が選択肢２）")
subplot(p1,p2)
```

### 反応時間の分布（事後予測１）

```{r, message=FALSE, warning=FALSE}
postPredData11 <- subset(postPredData1,postPredData$predRes==1)
p3 <- ggplot(postPredData11,aes(x = predRt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))
postPredData12 <- subset(postPredData1,postPredData$predRes==2)
p4 <- ggplot(postPredData12,aes(x = predRt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))+ ggtitle("事後予測の反応時間のヒストグラム　その１（左が選択肢１，右が選択肢２）")
subplot(p3,p4)
```

### 反応時間の分布（事後予測２）

```{r, message=FALSE, warning=FALSE}
postPredData21 <- subset(postPredData2,postPredData$predRes==1)
p5 <- ggplot(postPredData21,aes(x = predRt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))
postPredData22 <- subset(postPredData2,postPredData$predRes==2)
p6 <- ggplot(postPredData22,aes(x = predRt)) + geom_histogram()+coord_cartesian(xlim = c(0, 3), ylim = c(0, 70))+ ggtitle("事後予測の反応時間のヒストグラム　その２（左が選択肢１，右が選択肢２）")
subplot(p5,p6)
```

## 情報量基準(WAICとLOOCV)の算出
@berobero11氏の[Stan Advent 2016](http://statmodeling.hatenablog.com/entry/comparison-of-LOOCV-and-WAIC)を参考にしつつWAICとLOOCVの算出をしてみた。今回は，あまり意味ないけど，今後モデル比較する場合には，活用できるかなと思います。

```{r}
loo::loo(extractFit$log_lik)$looic/(2*trialLength)
loo::waic(extractFit$log_lik)$waic/(2*trialLength)
```

ここまで出来たら，複数の参加者のデータに対して階層ベイズにもっていきたいところですが，ちょっと分量が長くなりすぎてしまったので，またの機会に！  


**Enjoy Stan!**
